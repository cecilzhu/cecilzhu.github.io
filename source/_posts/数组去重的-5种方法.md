---
title: 数组去重的5种方法
date: 2022-03-11 16:20:34
updated: 2022-03-11 16:20:34
categories: 学习
tags: js
top: true
swiper_index: 4
top_group_index: 4
cover: /img/12.webp
main_color: '#857bae'
---

>var arr = [1, 2, 2, 3, 4, 4, 5, 6, 7, 7, 4, 3, 5, 7, 11, 12, 11];
>var newArr = [];

//**方法1最优 set对象**【Set是没有重复值的数据集合，传入一个需要去重的数组，Set会自动删   // newArr = Array.from(new Set(arr));
// console.log(newArr)
**//方法2时间短，占空间。newArr.indexOf**【遍历原数组的各项，每次判断新数组中是否存在该项，不存在就把当前项添加到新数组中。此法效率高，但占空间】
/* arr.forEach(function (item, index) { 
  if (newArr.indexOf(item) === -1) {
     newArr.push(item)
  }
}); * **/**

/* arr.forEach((item, index) => {// 方法2 箭头函数写法
  if (newArr.indexOf(item) === -1) {
     newArr.push(item)
  }
}); */
const m = new Map();

//【下面的方法用时依次增多！！】
// **方法3.1  map()** 【初始化一个可由 键值对 组成的集合m，形如二维数组。利用Map中 key的唯一性 同名覆盖。再遍历Map集合中的唯一key，并依次放入新数组newArr】

/*  for (let i = 0; i < arr.length; i++) {
  //  m.set(key, value);第一个值为key，注意与forEach((value, key, array)=>{ })参数顺序做区分。
  m.set(arr[i], true);//依次把arr中每一项，设定为m中的唯一key
}
m.forEach(function (item, index) {
  newArr.push(index)//注意：m集合中的key，此时是forEach中的index！之后把 唯一值 放入 新数组
});  */

// ***方法3.2，map() 是3.1的进阶，也是利用Map中 key的唯一性***
// 若m集合中不存在以当前arr项命名的key，就把当前项设置为m集合中的新key，同时把当前项放入新数组。
/* for (let i = 0; i < arr.length; i++) {
  if (!m.has(arr[i])) {
    m.set(arr[i])
    newArr.push(arr[i])
  }
}; */

//**方法4 filter+arr.indexOf**【遍历arr原数组中的每一项item和index，分别获取的每个item在arr中首项（唯一）的索引组成的集合 是arr原数组所有索引构成集合的一个 子集。返回在两种index一致时，即该索引子集 对应项 所组成的数组，拷贝给newArr】
/* newArr = arr.filter(function (item, index) {
  return arr.indexOf(item) == index;
});*/

//**方法5 reduce**【以作为initialValue的[]开始聚合，每次循环聚合返回的结果集_newArr也是数组。遍历原数组arr，拿arr的item依次进行判断：若 最新的 结果集 中，不存在arr的当前item，即把该项添加到结果集数组中。返回新结果集，继续下一个item判断】
/* newArr = arr.reduce((_newArr, item) => {
!_newArr.includes(item) && _newArr.push(item);
 // if (!_newArr.includes(item)) {
    _newArr.push(item);
 // }
  return _newArr;
}, []); */
// console.log(newArr);

------
```js
//需求3， 得到各数字每次出现的次数
console.log("各出现次数结果", arr.reduce((pre, cur) => {
//pre结果集（对象）中有以 当前项cur 作为key命名的。便把该key对应的value值pre[cur] 赋值给val。没有则初始化为0.
let val = pre[cur] || 0;
pre[cur] = ++val;//存在以 当前项cur 作为key命名的。便把该key对应的value值pre[cur]，+1
return pre;//每次循环， pre对象 结果集 可能不变/增加键值对/原有键值对的value,即pre[cur]+1
}, {})) */
```
